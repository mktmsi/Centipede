#define CheckMod -1

/****************************************************/
/* GLUT sample program                              */
/*                                                  */
/*                   Generated by Masahiro Shimizu  */
/*                    Apr., 10, 2007, Revision 0.1  */
/****************************************************/

#include <iostream>
#include <random>
//For Linux
//#include <GL/glut.h>
//For Mac
#include <GLUT/glut.h>
#include "Monitor.hpp"
#define dt (0.000002)    //タイムステップ
#define MAX_STEP (10000000)//最大タイムステップ数
#define g (4903.325)
#define pi (3.141592)
#define N (21)    //体節数
#define N_dekoboko (7)   //凹凸数
#define trunk(i,j)    trunk[(N+1)*(j)+(i)]
#define coxa(i,j)     coxa[(N)*(j)+(i)]
#define leg(i,j)      leg[(N)*(j)+(i)]

#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

/********************シミュレーション設定********************/
Monitor monitor;
int winid;

FILE *fp;

const int save_flag = 1;      //0:画像保存しない. 1:画像保存するcd cd
const int muscle_properity = 1; //0:筋特性無し．1:筋特性有り
const int FTC_control = 1;      //0:接地点追従無し．1:接地点追従有り
const int CP_get = 1;         //0:接地点出現無し．1:接地点出現有り
const int CP_lost = 1;      //0:接地点消失無し．1:接地点消失有り

int time_step = 0;
int interval = 2000;
char string[25];

/*********************身体パラメータ********************/
//質点
const double m_trunk_tip = 0.01 , m_trunk = 0.05 , m_coxa = 0.01 , m_leg = 0.005;

//Link
const double c_tc = 100.0 , k_tc = 10000000.0 , leq_tc = 1.0; //trunk-coxa間リンク
const double c_ct = c_tc , k_ct = k_tc , leq_ct = leq_tc; //coxa-trunk間リンク

//RTS
const double c_cl = 10.0 , k_cl = 1000.0; //楕円型
// const double c_cl = 100.0 , k_cl = 10000.0; //かまぼこ型
const double leq_cl = 3.0;

//Coil
const double c_tct   = 100.0 ,    k_tct   = 100000000.0 ,    phieq_tct   = pi;         //coxaのコイル　ガチガチ
const double c_ctc   = 100.0 ,    k_ctc   = 1000000.0 ,    phieq_ctc   = pi;             //trunkのコイル ゆるゆる
const double c_tcl   = 100.0,     k_tcl   = 1000000.0 ,    phieq_tcl   = pi/2.0;          //tcl前方のコイル

/*********************制御パラメータ********************/

const double x_AEP = 2.3 , x_PEP = 2.3;

const double x_wait = 0.3*x_AEP , N_contact = 100.0;
const double x_lost = -0.3*x_AEP , N_lost = 100.0;
const double x_get  = 0.0*x_AEP , N_get    = 100.0;

const double Vswing = 5.0 , Vstance = 5.0 , Vlanding = 3.0*Vstance;
const double bar_phi_vmax = 30.0;

const double L = leq_cl;
const double alfa  = 0.0 * leq_cl;
const double beta1 = 0.6 * leq_cl;
const double beta2 = 0.3 * leq_cl;

const double tau_0 = 5000.0;

/*********************地面パラメータ********************/

//地面の粘弾要素
const double c_g = 1000.0 , k_g = 1000000.0;  

//摩擦
const double mu = 0.5;
const double c_tanh = 10.0;     //動摩擦力導出時の双曲線関数パラメータ

//地面の凹凸
double x_gap_L[N_dekoboko] , x_gap_R[N_dekoboko];
const double boko = 4.0, deko = 2.0;
const double boko_start = 5.0*(deko + boko);

/*********************ベクトル演算*******************/
typedef struct{double x,z;} C2DVec;

C2DVec operator +(C2DVec a,C2DVec b){C2DVec c;  c.x = a.x + b.x;  c.z = a.z + b.z;  return c;}
C2DVec operator -(C2DVec a,C2DVec b){C2DVec c;  c.x = a.x - b.x;  c.z = a.z - b.z;  return c;}
C2DVec ax(double a,C2DVec b){C2DVec c;  c.x = a * b.x;   c.z = a * b.z;   return c;}
C2DVec wx(double a,C2DVec b){C2DVec c;  c.x = b.x / a;   c.z = b.z / a;   return c;}
double operator *(C2DVec a,C2DVec b){double c; c = a.x * b.x + a.z * b.z;   return c;}
double abs(C2DVec a){double c;  c = sqrt(a.x*a.x + a.z*a.z);   return c;}
C2DVec rot90(C2DVec a){C2DVec b;   b.x = -a.z;   b.z = a.x;    return b;}
C2DVec rot270(C2DVec a){C2DVec b;   b.x = a.z;   b.z = -a.x;    return b;}
C2DVec rot(double a,C2DVec b){
    C2DVec c;
    c.x=cos(a)*b.x-sin(a)*b.z;
    c.z=sin(a)*b.x+cos(a)*b.z;
    return c;
}
C2DVec unit(C2DVec a){
    C2DVec b;
    if(abs(a)==0.0){
        b.x = 0.0;
        b.z = 0.0;
    }else{
        b.x=a.x/sqrt(a.x*a.x+a.z*a.z);
        b.z=a.z/sqrt(a.x*a.x+a.z*a.z);
    }
    return b;
}
/*******************Max,min関数の定義*******************/
double max(double a, double b) { return a > b ? a : b; }
double min(double a, double b) { return a < b ? a : b; }

/*********************質点********************/
class Mass{
private:
public:
    double m;
    C2DVec r,v,F;
    std::string state;
    int state_num;
    void draw();
};
void Mass::draw(){
    monitor.DrawCircle(r.x, r.z, 0.1);
}

Mass trunk[6*(N+1)];
Mass coxa[6*N];
Mass leg[6*N];

/*********************リンク********************/
class Link{
private:
public:
    double c_link,k_link;
    double l_link;
    C2DVec f_spring, f_damper;
    C2DVec spring(Mass mass1, Mass mass2);
    C2DVec damper(Mass mass1, Mass mass2);
    void draw(Mass mass1, Mass mass2);
};
C2DVec Link::spring(Mass mass1, Mass mass2){
    C2DVec vector;
    double force;
    vector = mass1.r - mass2.r;
    force = k_link * pow( (abs(vector) - l_link), 3.0 );
    f_spring = ax( force , unit(vector) );
    return f_spring;
}
C2DVec Link::damper(Mass mass1, Mass mass2){
    C2DVec vector_r,vector_v;
    double force;
    vector_r = mass1.r - mass2.r;
    vector_v = mass1.v - mass2.v;
    force = c_link * ( vector_v * unit(vector_r) );
    f_damper = ax( force , unit(vector_r) );
    return f_damper;
}

Link link_tc[N];
Link link_ct[N];

/*********************RTS********************/
class RTS{
private:
public:
    double c_rts,k_rts;
    double l_rts;
    C2DVec f_spring, f_damper;
    C2DVec spring(Mass mass1, Mass mass2);
    C2DVec damper(Mass mass1, Mass mass2);
    void draw(Mass mass1, Mass mass2);
};
C2DVec RTS::spring(Mass mass1, Mass mass2){
    C2DVec vector;
    double force;
    vector = mass1.r - mass2.r;
    force = k_rts * pow( (abs(vector) - l_rts), 1.0 );
    f_spring = ax( force , unit(vector) );
    return f_spring;
}
C2DVec RTS::damper(Mass mass1, Mass mass2){
    C2DVec vector_r,vector_v;
    double force;
    vector_r = mass1.r - mass2.r;
    vector_v = mass1.v - mass2.v;
    force = c_rts * ( vector_v * unit(vector_r) );
    f_damper = ax( force , unit(vector_r) );
    return f_damper;
}
void RTS::draw(Mass mass1, Mass mass2){
    monitor.DrawLine(mass1.r.x, mass1.r.z, mass2.r.x, mass2.r.z, 2.0);
}

RTS rts_cl[N];

/*********************巻バネ・ダンパ********************/
class Coil{
private:
public:
    double c_coil,k_coil;
    double phi_coil;
    double tau();
    double tau_limit(double tau_0, double bar_phi_v);
    double phi;
    double phi_v;
};
double Coil::tau(){
    
    return k_coil*(phi - phi_coil) + c_coil*phi_v;
}
double Coil::tau_limit(double tau_0, double bar_phi_v ){
    
    /**筋特性**/
//    if(       k_coil*(phi - phi_coil) + c_coil*phi_v >    tau_0*(1.0 -  ( fabs(phi_v/bar_phi_v) ) ) ){
//        return   max( tau_0*(1.0 -  ( fabs(phi_v/bar_phi_v) ) ) , 0.0 );
//    }else if( k_coil*(phi - phi_coil) + c_coil*phi_v <  - tau_0*(1.0 -  ( fabs(phi_v/bar_phi_v) ) ) ){
//        return   min( - tau_0*(1.0 -  ( fabs(phi_v/bar_phi_v) ) ) , 0.0 );
//    }else{
//        return k_coil*(phi - phi_coil) + c_coil*phi_v;
//    }

    /**筋特性with脱力**/
    // if( fabs(phi_v) > bar_phi_vmax ){
    //     return 0.0;
    // }else if(       k_coil*(phi - phi_coil) + c_coil*phi_v >   tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax )   ){
    //     return   tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax );
    // }else if( k_coil*(phi - phi_coil) + c_coil*phi_v < - tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax )   ){
    //     return - tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax );
    // }else{
    //     return k_coil*(phi - phi_coil) + c_coil*phi_v;
    // }

    /**筋特性**/
    // if(       k_coil*(phi - phi_coil) + c_coil*phi_v >   tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax )   ){
    //     return   tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax );
    // }else if( k_coil*(phi - phi_coil) + c_coil*phi_v < - tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax )   ){
    //     return - tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax );
    // }else{
    //     return k_coil*(phi - phi_coil) + c_coil*phi_v;
    // }

    /**筋特性(支持脚だけ上限)**/
    // if(       - k_coil*(phi - phi_coil) + c_coil*phi_v <   tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax )   ){
    //     return   - tau_0*(1.0  -  fabs(phi_v)/bar_phi_vmax );
    // }else{
    //     return k_coil*(phi - phi_coil) + c_coil*phi_v;
    // }
    
    /**簡易版筋特性**/
    if(       k_coil*(phi - phi_coil) + c_coil*phi_v >    tau_0 ){
        return   tau_0;
    }else if( k_coil*(phi - phi_coil) + c_coil*phi_v <  - tau_0 ){
        return - tau_0;
    }else{
        return k_coil*(phi - phi_coil) + c_coil*phi_v;
    }
}

Coil coil_tcl[N];
Coil coil_tct[N];
Coil coil_ctc[N];

/*******************脚軌道*******************/
class Trajectory{
    private:
    public:
        std::string trajectory_shape;
        double leg_length(std::string state , double x);
        double leg_z(std::string ,double x);
};

//楕円型
double Trajectory::leg_length(std::string state , double x){
    if(state == "swing"){
        return L - max( beta1 * sin( (x + x_PEP) * pi/(x_AEP + x_PEP) ) , 0.0 );
    }else if(state == "stance"){
        return L;
    }
}

//maxなし軌道
// double Trajectory::leg_length(std::string state , double x){
//     if(state == "swing"){
//         return L - beta1 * sin( (x + x_PEP) * pi/(x_AEP + x_PEP) );
//     }else if(state == "stance"){
//         return L;
//     }
// }

double Trajectory::leg_z(std::string state, double x){
    double l_zero = leg_length(state, x);
    return L - sqrt( l_zero*l_zero - x*x );
}

//かまぼこ型
// double Trajectory::leg_length(std::string state , double x){
//     if(state == "swing"){
//         return sqrt( x*x + L*L - x_AEP*x_AEP ) - max( beta2* sin( (x + x_PEP) * pi/(x_AEP + x_PEP) ) , 0.0 );
//     }else if(state == "stance"){
//         return sqrt( x*x + L*L - x_AEP*x_AEP) + max( alfa * sin( (x + x_PEP) * pi/(x_AEP + x_PEP) ) , 0.0 );
//     }
// }
// double Trajectory::leg_z(std::string state, double x){
//     double l_zero = leg_length(state, x);
//     return sqrt( x*x + L*L - x_AEP*x_AEP ) + max( alfa * sin( (x + x_PEP) * pi/(x_AEP + x_PEP) ) , 0.0 ) - sqrt( l_zero*l_zero - x*x );
// }

Trajectory T_leg;

/*********************脚の状態クラス********************/
std::string state[N];

/*******************方向・法線ベクトル*******************/
C2DVec et_tc[N], et_ct[N], et_cl[N];
C2DVec en_tc[N], en_ct[N], en_cl[N];

/*******************Link間の実長*******************/
double l_tc[N],  l_ct[N],  l_cl[N];

/*******************tct二等分角*******************/
C2DVec childa[N];
double psi[N] ,kai[N];

/*******************目標位置，速度*******************/
double barl[N];
double dotbartheta[N];
/*******************床反力*******************/
C2DVec Fl_N[N], Fc_N[N], Ft_N[N+1];

/*******************地面*******************/

void ground(Mass *mass , C2DVec *F_N){

    if(N_dekoboko == 0){
        if(mass->r.z > 0.0){
            mass->state = "N";
        }else{
            mass->state = "O";
        }
    }else{
        if(mass->r.z > 0.0){
            mass->state = "N";
        }else{
            if(mass->r.x < x_gap_L[0]){
                if( fabs(mass->r.z) > fabs(mass->r.x - x_gap_L[0]) ){
                    mass->state = "L";
                    mass->state_num = 0;
                }else{
                    mass->state = "O";
                }
            }else if(x_gap_R[N_dekoboko - 1] < mass->r.x){
                if(fabs(mass->r.z) > fabs(mass->r.x - x_gap_R[N_dekoboko - 1]) ){
                    //mass->state = "R";
                    mass->state = "O";
                    mass->state_num = N_dekoboko - 1;
                }else{
                    mass->state = "O";
                }
            }else{
                for(int j=0; j< N_dekoboko -1; ++j){
                    if(x_gap_R[j] < mass->r.x && mass->r.x < x_gap_R[j] + deko/2.0){
                        if( fabs(mass->r.z) > fabs(mass->r.x - x_gap_R[j]) ){
                            //mass->state = "R";
                            mass->state = "O";
                            mass->state_num = j;
                        }else{
                            mass->state = "O";
                        }
                        break;
                    }else if(x_gap_R[j] + deko/2.0 <= mass->r.x && mass->r.x < x_gap_L[j+1] ){
                        if( fabs(mass->r.z) > fabs(mass->r.x - x_gap_R[j]) ){
                            mass->state = "L";
                            mass->state_num = j;
                        }else{
                            mass->state = "O";
                        }
                        break;
                    }else{
                        mass->state = "N";
                    }
                }
            }
        }
    }
    if(mass->state == "O"){
        F_N->x = 0.0;
        F_N->z = max( -k_g * mass->r.z - c_g * mass->v.z , 0);
    }else if(mass->state == "N"){
        F_N->x = 0.0;
        F_N->z = 0.0;
    }else if(mass->state == "L"){
        F_N->x = max( -k_g * (mass->r.x - x_gap_L[mass->state_num + 1]) - c_g * mass->v.x , 0);
        F_N->z = 0.0;
    }else if(mass->state == "R"){
        F_N->x = min( -k_g * (mass->r.x - x_gap_R[mass->state_num]) - c_g * mass->v.x , 0);
        F_N->z = 0.0;
    }
}

/*********************初期値設定********************/
void init(){
    int i,j;
    char filename[256];
    sprintf(filename, "data.txt");
    fp = fopen(filename,"w");
    
    //state(random)
    std::random_device rnd_state;     // 非決定的な乱数生成器を生成
    std::mt19937 mt(rnd_state());     //  メルセンヌ・ツイスタの32ビット版、引数は初期シード値
    std::uniform_int_distribution<> rand100(0, 99);        // [0, 99] 範囲の一様乱数
    for(i=0;i<N;++i){
        if(rand100(mt)%2 == 0){
            state[i] = "stance";
        }else{
            state[i] = "swing";
        }
    }
    
    //Mass(trunk)
    for(i=0;i<N+1;i++){
        for(j=0;j<6;++j){
            if(i==0 || i==N){
                trunk(i,j).m = m_trunk_tip;
            }else{
            trunk(i,j).m = m_trunk;
            }
        }
        trunk(i,0).v.z = 0.0;
        trunk(i,0).v.x = 0.0;
        trunk(i,0).r.z = T_leg.leg_length("stance",0.0);
        trunk(i,0).r.x = leq_tc - 2*leq_tc*i;
    }
    //Mass(coxa)
    for(i=0;i<N;i++){
        for(j=0;j<6;++j){
            coxa(i,j).m = m_coxa;
        }
        coxa(i,0).v.z = 0.0;
        coxa(i,0).v.x = 0.0;
        coxa(i,0).r.z = T_leg.leg_length("stance",0.0);
        coxa(i,0).r.x = 0.0 - 2*leq_tc*i;
    }
    //Mass(leg)
    std::random_device rnd_leg;     // 非決定的な乱数生成器を生成
    std::mt19937 mt1(rnd_leg());     //  メルセンヌ・ツイスタの32ビット版、引数は初期シード値
    std::uniform_int_distribution<> rand_leg(-x_PEP*10000, x_AEP*10000);        // [0, 99] 範囲の一様乱数
    for(i=0;i<N;i++)
    {
        for(j=0;j<6;++j){
            leg(i,j).m = m_leg;
        }
        leg(i,0).v.z = 0.0;
        leg(i,0).v.x = 0.0;
        
        //xの位置をrandomで決定
        leg(i,0).r.x = (rand_leg(mt)/10000.0)  - 2*leq_tc*i;
        while(leg(i,0).r.x > leg(i-1,0).r.x && i!= 0){
            leg(i,0).r.x = (rand_leg(mt)/10000.0)  - 2*leq_tc*i;
        }
        //zの位置を決定
        leg(i,0).r.z = T_leg.leg_z(state[i], leg(i,0).r.x - coxa(i,0).r.x);
    }
   
    //Link
    for(i=0;i<N;++i){
        link_ct[i].c_link = c_tc;
        link_ct[i].k_link = k_tc;
        link_ct[i].l_link = leq_tc;
        
        link_tc[i].c_link = c_ct;
        link_tc[i].k_link = k_ct;
        link_tc[i].l_link = leq_ct;
    }
    //RTS
    for(i=0;i<N;++i){
        rts_cl[i].c_rts = c_cl;
        rts_cl[i].k_rts = k_cl;
        rts_cl[i].l_rts = sqrt( (leg(i,0).r.x - coxa(i,0).r.x)*(leg(i,0).r.x - coxa(i,0).r.x) +  (leg(i,0).r.z - coxa(i,0).r.z)*(leg(i,0).r.z - coxa(i,0).r.z) );
        
    }
    //Coil
    for(i=0;i<N;++i){
        coil_ctc[i].c_coil   = c_ctc;
        coil_ctc[i].k_coil   = k_ctc;
        coil_ctc[i].phi_coil = phieq_ctc;
        
        coil_tct[i].c_coil   = c_tct;
        coil_tct[i].k_coil   = k_tct;
        coil_tct[i].phi_coil = phieq_tct;
        
        coil_tcl[i].c_coil   = c_tcl;
        coil_tcl[i].k_coil   = k_tcl;
        if(leg(i,0).r.x + 2*leq_tc*i > 0.0){
            coil_tcl[i].phi_coil = acos( ( leg(i,0).r.x + 2*leq_tc*i ) / rts_cl[i].l_rts);
        }else if(leg(i,0).r.x + 2*leq_tc*i < 0.0){
            coil_tcl[i].phi_coil = pi/2.0 + asin( -( leg(i,0).r.x + 2*leq_tc*i ) / rts_cl[i].l_rts);
        }else{
            coil_tcl[i].phi_coil = pi/2.0;
        }
    }
    
    //地面の設定
    for(int i=0; i<N_dekoboko; ++i){
        x_gap_L[i] = (deko + boko)*i + boko_start;
        x_gap_R[i] = (deko + boko)*i + boko_start + boko;
    }
    
}

/*********************制御計算関数********************/

void calculate(Mass *t, Mass *c, Mass *l){

    for(int i=0; i<N_dekoboko; ++i){
        x_gap_L[i] = (deko + boko)*i + boko_start;
        x_gap_R[i] = (deko + boko)*i + boko_start + boko;
    }
    
    /******************方向，法線ベクトルの計算********************/
    
    for(int i=0;i<N;++i){
        
        et_tc[i] = unit(t[i].r - c[i].r);
        en_tc[i] = rot90(et_tc[i]);
        
        et_ct[i] = unit(c[i].r - t[i+1].r);
        en_ct[i] = rot90(et_ct[i]);
        
        et_cl[i] = unit(c[i].r - l[i].r);
        en_cl[i] = rot270(et_cl[i]);
        
    }
    
    /******************リンク実長の計算********************/
    
    for(int i=0;i<N;++i){
        l_tc[i] = abs(t[i].r - c[i].r);
        l_ct[i] = abs(c[i].r - t[i+1].r);
        l_cl[i] = abs(c[i].r - l[i].r);
    }
    
    /******************Coilの計算********************/
    
    //coil_tcl
    for(int i=0;i<N;++i){
        coil_tcl[i].phi_v = - ( (l[i].v - c[i].v) * en_cl[i] ) / l_cl[i] + ( (t[i].v - c[i].v) * en_tc[i] ) / l_tc[i];
        coil_tcl[i].phi = pi - atan2(c[i].r.z - l[i].r.z , c[i].r.x - l[i].r.x) + atan2(t[i].r.z - c[i].r.z , t[i].r.x - c[i].r.x);
        if(coil_tcl[i].phi>2*pi){coil_tcl[i].phi-=2*pi;}
        if(coil_tcl[i].phi<0.0){coil_tcl[i].phi+=2*pi;}
    }
    
    //coil_tct
    for(int i=0;i<N;++i){
        coil_tct[i].phi_v = - ( (t[i].v - c[i].v) * en_tc[i] ) / l_tc[i]  -  ( (t[i+1].v - c[i].v) * en_ct[i]) / l_ct[i];
        coil_tct[i].phi = pi + atan2(c[i].r.z - t[i+1].r.z , c[i].r.x - t[i+1].r.x) - atan2(t[i].r.z - c[i].r.z , t[i].r.x - c[i].r.x);
        if(coil_tct[i].phi>2*pi){coil_tct[i].phi-=2*pi;}
        if(coil_tct[i].phi<0.0){coil_tct[i].phi+=2*pi;}
    }
    
    //coil_ctc
    for(int i=0;i<N+1;++i){
        if(i==0 || i==N){
        }else{
            coil_ctc[i].phi_v = - ( (c[i-1].v - t[i].v) * en_ct[i-1] ) / l_ct[i-1]  -  ( (c[i].v - t[i].v) * en_tc[i] ) / l_tc[i];
            coil_ctc[i].phi = pi + atan2(t[i].r.z - c[i].r.z , t[i].r.x - c[i].r.x) - atan2(c[i-1].r.z - t[i].r.z , c[i-1].r.x - t[i].r.x);
            if(coil_ctc[i].phi>2*pi){coil_ctc[i].phi-=2*pi;}
            if(coil_ctc[i].phi<0.0){coil_ctc[i].phi+=2*pi;}
        }
    }

    /******************脚状態の決定********************/
    
    //角度計算
    for(int i=0;i<N;++i){
        coil_tcl[i].phi_coil = coil_tcl[i].phi_coil - psi[i];  //tcl(t-1) - psi(t-1)
        psi[i] = (pi - coil_tct[i].phi) / 2.0;                 //psi(t)
        kai[i] = atan2( t[i].r.z - t[i+1].r.z , t[i].r.x - t[i+1].r.x );
    }
    //coxa基準座標変換
    for(int i=0;i<N;++i){
        childa[i] = rot(kai[i] , l[i].r - c[i].r);
    }
    
    //目標速度
    for(int i=0;i<N;++i){
        C2DVec et_cc;
        double theta_ccl;
        
        et_cc = unit(c[i-1].r - c[i].r);
        theta_ccl = pi - atan2( c[i].r.z - l[i].r.z , c[i].r.x - l[i].r.x ) + atan2( c[i-1].r.z - c[i].r.z , c[i-1].r.x - c[i].r.x );
        //支持脚の制御
        if(state[i] == "stance"){
            
            dotbartheta[i] = Vstance;
            barl[i] = T_leg.leg_length("stance" , childa[i].x);
            //伸張反射
            if(childa[i].x < -x_PEP){
                state[i] = "swing";
            }
            //接地点消失
            if(CP_lost == 1){
                if( childa[i].x < x_lost && Fl_N[i].z + Fl_N[i].x <= N_lost ){
                state[i] = "swing";
                }
            }
            //支持脚期から接地点追従期の遷移あり
            // if(FTC_control == 1){
            //     if( ( abs(c[i-1].r - c[i].r) <  (c[i-1].r - l[i-1].r)*et_cc + (l[i].r - c[i].r)*et_cc ) && (i != 0) && Fl_N[i-1].z > N_contact ){
            //         state[i] = "landing";
            //     }
            // }
        //遊脚の制御
        }else if(state[i] == "swing"){
            
            if(childa[i].x > x_wait && Fl_N[i-1].z < N_contact && i!=0){
                dotbartheta[i] = 0.0;
            }else{
                dotbartheta[i] = -Vswing;
            }
            barl[i] = T_leg.leg_length("swing" , childa[i].x);
            
            //伸張反射
            if(childa[i].x > x_AEP){
                state[i] = "stance";
            }

            //接地点増加
            if(CP_get == 1){
                if(childa[i].x > x_get && Fl_N[i].z + Fl_N[i].x > N_get){
                    state[i] = "stance";
                }
            }
            //接地点追従
            if(FTC_control == 1){
                if( ( abs(c[i-1].r - c[i].r) <  (c[i-1].r - l[i-1].r)*et_cc + (l[i].r - c[i].r)*et_cc ) && (i != 0) && Fl_N[i-1].z > N_contact ){
                    state[i] = "landing";
                }
            }
            // if(FTC_control == 1){
            //     if( ( abs(c[i-1].r - c[i].r) <  (c[i-1].r - l[i-1].r)*et_cc + (l[i].r - c[i].r)*et_cc ) && (i != 0)  ){
            //         state[i] = "landing";
            //     }
            // }
        //接地点追従制御
        }else if(state[i] == "landing"){
            
            dotbartheta[i] = Vlanding;
            //barl[i] = ( abs(c[i-1].r - c[i].r) - (c[i-1].r - l[i-1].r)*et_cc )  / cos( theta_ccl + dt*dotbartheta[i] );
            barl[i] = ( abs(c[i-1].r - c[i].r) - (c[i-1].r - l[i-1].r)*et_cc )  / cos( theta_ccl );
            if(childa[i].x < 0.01){
                barl[i] = T_leg.leg_length("stance", childa[i].x);
                state[i] = "stance";
            }
            //支持脚期の軌道まで達したら接地点追従終了
            if(barl[i] > T_leg.leg_length("stance", childa[i].x) ){
                state[i] = "stance";
            }
            //荷重を感じたら接地点追従終了
            if(Fl_N[i].z > N_contact ){
                state[i] = "stance";
            }
            //接地点追従中に前脚の荷重が少なくなったら遊脚に戻る
            if(Fl_N[i-1].z < N_contact && i != 0 ){
                state[i] = "swing";
            }

        }
    }
    
    /******************RTS,Coilの制御********************/

    for(int i=0;i<N;++i){
        rts_cl[i].l_rts = barl[i];
        coil_tcl[i].phi_coil = psi[i] + coil_tcl[i].phi_coil + dt * dotbartheta[i];
//        coil_tcl[i].phi_v = dotbartheta[i];
    }

}

/*********************運動方程式関数********************/
    
void func(Mass *t, Mass *t_out, Mass *c, Mass *c_out, Mass *l, Mass *l_out){

    /*********************Trunkの運動方程式********************/
    
    C2DVec Ft_sd[N+1], Ft_mg[N+1], Ft_torque[N+1], Ft_friction[N+1];
    
    for(int i=0;i<N+1;++i){
        
        ground( &t[i] , &Ft_N[i] );
        
        Ft_friction[i].x = - mu * fabs(Ft_N[i].z) * tanh(c_tanh * t[i].v.x);
        Ft_friction[i].z = - mu * fabs(Ft_N[i].x) * tanh(c_tanh * t[i].v.z);
        
        if(i==0){
            Ft_sd[i] =   link_tc[i].spring(c[i],t[i]) + link_tc[i].damper(c[i],t[i]);
            
            if(muscle_properity == 0){
                Ft_torque[i] =    ax(   coil_tct[i].tau()   / l_tc[i] , en_tc[i])
                                + ax( - coil_tcl[i].tau()   / l_tc[i] , en_tc[i]);
            }else{
                Ft_torque[i] =    ax(   coil_tct[i].tau()   / l_tc[i] , en_tc[i])
                                + ax( - coil_tcl[i].tau_limit(tau_0 , dotbartheta[i] )   / l_tc[i] , en_tc[i]);
            }
            
        }
        else if(i==N){
            Ft_sd[i] =   link_ct[i-1].spring(c[i-1],t[i]) + link_ct[i-1].damper(c[i-1],t[i]);
            
            Ft_torque[i] =   ax(   coil_tct[i-1].tau() / l_ct[i-1] , en_ct[i-1]);
            
        }
        else{
            Ft_sd[i] =   link_ct[i-1].spring(c[i-1],t[i]) + link_ct[i-1].damper(c[i-1],t[i])
                       + link_tc[i].spring(c[i],t[i])     + link_tc[i].damper(c[i],t[i]);
            
            if(muscle_properity == 0){
                Ft_torque[i] =   ax(  -coil_ctc[i].tau()   / l_ct[i-1] , en_ct[i-1] )
                               + ax(  -coil_ctc[i].tau()   / l_tc[i]   , en_tc[i]   )
                               + ax(   coil_tct[i].tau()   / l_tc[i]   , en_tc[i]   )
                               + ax(   coil_tct[i-1].tau() / l_ct[i-1] , en_ct[i-1] )
                               + ax( - coil_tcl[i].tau()   / l_tc[i]   , en_tc[i]   );
            }else{
                Ft_torque[i] =   ax(  -coil_ctc[i].tau()   / l_ct[i-1] , en_ct[i-1] )
                               + ax(  -coil_ctc[i].tau()   / l_tc[i]   , en_tc[i]   )
                               + ax(   coil_tct[i].tau()   / l_tc[i]   , en_tc[i]   )
                               + ax(   coil_tct[i-1].tau() / l_ct[i-1] , en_ct[i-1] )
                               + ax( - coil_tcl[i].tau_limit(tau_0 , dotbartheta[i] )   / l_tc[i]   , en_tc[i]   );
            }
        }
        
        Ft_mg[i].x = 0.0;
        Ft_mg[i].z = -t[i].m * g;
        
        t[i].F = Ft_mg[i] + Ft_sd[i] + Ft_torque[i] + Ft_N[i] + Ft_friction[i];
    }
    
    /*********************Coxaの運動方程式********************/
    
    C2DVec Fc_sd[N], Fc_mg[N], Fc_torque[N], Fc_friction[N];
    
    for(int i=0;i<N;++i){
        
        ground( &c[i] , &Fc_N[i] );
              
        Fc_friction[i].x = - mu * fabs(Fc_N[i].z) * tanh(c_tanh * c[i].v.x);
        Fc_friction[i].z = - mu * fabs(Fc_N[i].x) * tanh(c_tanh * c[i].v.z);
        
        Fc_sd[i] =    rts_cl[i].spring(l[i],c[i])    + rts_cl[i].damper(l[i],c[i])
                    + link_tc[i].spring(t[i],c[i])   + link_tc[i].damper(t[i],c[i])
                    + link_ct[i].spring(t[i+1],c[i]) + link_ct[i].damper(t[i+1],c[i]);
        
        if(muscle_properity == 0){
            Fc_torque[i] =   ax( - coil_tct[i].tau()   / l_tc[i] , en_tc[i])
                           + ax( - coil_tct[i].tau()   / l_ct[i] , en_ct[i])
                           + ax(   coil_tcl[i].tau()   / l_tc[i] , en_tc[i])
                           + ax( - coil_tcl[i].tau()   / l_cl[i] , en_cl[i]);
        }else{
            Fc_torque[i] =   ax( - coil_tct[i].tau()   / l_tc[i] , en_tc[i])
                           + ax( - coil_tct[i].tau()   / l_ct[i] , en_ct[i])
                           + ax(   coil_tcl[i].tau_limit(tau_0 , dotbartheta[i] )   / l_tc[i] , en_tc[i])
                           + ax( - coil_tcl[i].tau_limit(tau_0 , dotbartheta[i] )   / l_cl[i] , en_cl[i]);
        }
        
        //体節の場合分け
        if(N==1){
            
        }else{
            if(i==0){
                Fc_torque[i] = Fc_torque[i] + ax(   coil_ctc[i+1].tau() / l_ct[i] , en_ct[i]);
            }else if(i==N-1){
                Fc_torque[i] = Fc_torque[i] + ax(   coil_ctc[i].tau()   / l_tc[i] , en_tc[i]);
            }else{
                Fc_torque[i] = Fc_torque[i] + ax(   coil_ctc[i].tau()   / l_tc[i] , en_tc[i])
                                            + ax(   coil_ctc[i+1].tau() / l_ct[i] , en_ct[i]);
            }
        }
        
        Fc_mg[i].x = 0.0;
        Fc_mg[i].z = -c[i].m * g;
        
        c[i].F = Fc_sd[i] + Fc_torque[i] + Fc_mg[i] + Fc_N[i] + Fc_friction[i];
        
    }
    
    /*********************Legの運動方程式********************/
    
    C2DVec Fl_sd[N], Fl_mg[N], Fl_torque[N], Fl_friction[N];
    
    for(int i=0;i<N;++i){

        ground( &l[i] , &Fl_N[i] );
        
        Fl_friction[i].x = - mu * fabs(Fl_N[i].z) * tanh(c_tanh * l[i].v.x);
        Fl_friction[i].z = - mu * fabs(Fl_N[i].x) * tanh(c_tanh * l[i].v.z);

        Fl_sd[i] = rts_cl[i].spring(c[i],l[i]) + rts_cl[i].damper(c[i],l[i]);
        
        //筋特性によるトルクの制限
        if(muscle_properity == 0){
            Fl_torque[i] =  ax(  coil_tcl[i].tau() / l_cl[i] , en_cl[i] );
        }else{
            Fl_torque[i] =  ax(  coil_tcl[i].tau_limit(tau_0 , dotbartheta[i] ) / l_cl[i] , en_cl[i] );
        }
        
        Fl_mg[i].x = 0.0;
        Fl_mg[i].z = -l[i].m * g;
        
        l[i].F = Fl_sd[i] + Fl_torque[i] + Fl_N[i] + Fl_friction[i] + Fl_mg[i];
        
    }

    /*********************微分方程式********************/
    for(int i=0;i<N+1;++i){
        t_out[i].v = ax(dt/t[i].m , t[i].F);
        t_out[i].r = ax(dt        , t[i].v);
    }
    for(int i=0;i<N;++i){
        c_out[i].v = ax(dt/c[i].m , c[i].F);
        c_out[i].r = ax(dt        , c[i].v);
        l_out[i].v = ax(dt/l[i].m , l[i].F);
        l_out[i].r = ax(dt        , l[i].v);
    }
}

/*********************ルンゲクッタ********************/

int runge(void){
    int i,j;
    double t;
    
    for (i=0; i<interval; i++) {    //interval回に1回displayに戻って描画がなされる
        
        calculate(&trunk(0,0),&coxa(0,0),&leg(0,0));
        func(&trunk(0,0),&trunk(0,1),&coxa(0,0),&coxa(0,1),&leg(0,0),&leg(0,1));
        for (j=0; j<N; ++j){
            coxa(j,5).r = coxa(j,0).r + wx(2.0,coxa(j,1).r);
            coxa(j,5).v = coxa(j,0).v + wx(2.0,coxa(j,1).v);
            leg(j,5).r  = leg(j,0).r  + wx(2.0,leg(j,1).r);
            leg(j,5).v  = leg(j,0).v  + wx(2.0,leg(j,1).v);
        }
        for (j=0; j<N+1; ++j){
            trunk(j,5).r = trunk(j,0).r + wx(2.0,trunk(j,1).r);
            trunk(j,5).v = trunk(j,0).v + wx(2.0,trunk(j,1).v);
        }
        
        func(&trunk(0,5),&trunk(0,2),&coxa(0,5),&coxa(0,2),&leg(0,5),&leg(0,2));
        for(j=0; j<N; ++j){
            coxa(j,5).r = coxa(j,0).r + wx(2.0,coxa(j,2).r);
            coxa(j,5).v = coxa(j,0).v + wx(2.0,coxa(j,2).v);
            leg(j,5).r  = leg(j,0).r  + wx(2.0,leg(j,2).r);
            leg(j,5).v  = leg(j,0).v  + wx(2.0,leg(j,2).v);
        }
        for(j=0; j<N+1; ++j){
            trunk(j,5).r = trunk(j,0).r + wx(2.0,trunk(j,2).r);
            trunk(j,5).v = trunk(j,0).v + wx(2.0,trunk(j,2).v);
        }
        
        func(&trunk(0,5),&trunk(0,3),&coxa(0,5),&coxa(0,3),&leg(0,5),&leg(0,3));
        for(j=0; j<N; ++j){
            coxa(j,5).r = coxa(j,0).r + coxa(j,3).r;
            coxa(j,5).v = coxa(j,0).v + coxa(j,3).v;
            leg(j,5).r  = leg(j,0).r  + leg(j,3).r;
            leg(j,5).v  = leg(j,0).v  + leg(j,3).v;
        }
        for(j=0; j<N+1; ++j){
            trunk(j,5).r = trunk(j,0).r + trunk(j,3).r;
            trunk(j,5).v = trunk(j,0).v + trunk(j,3).v;
        }
        
        func(&trunk(0,5),&trunk(0,4),&coxa(0,5),&coxa(0,4),&leg(0,5),&leg(0,4));
        for(j=0; j<N; ++j){
            coxa(j,0).r = coxa(j,0).r + wx(6.0,(coxa(j,1).r + ax(2.0,coxa(j,2).r) + ax(2.0,coxa(j,3).r) + coxa(j,4).r));
            coxa(j,0).v = coxa(j,0).v + wx(6.0,(coxa(j,1).v + ax(2.0,coxa(j,2).v) + ax(2.0,coxa(j,3).v) + coxa(j,4).v));
            leg(j,0).r  = leg(j,0).r  + wx(6.0,(leg(j,1).r  + ax(2.0,leg(j,2).r)  + ax(2.0,leg(j,3).r)  + leg(j,4).r));
            leg(j,0).v  = leg(j,0).v  + wx(6.0,(leg(j,1).v  + ax(2.0,leg(j,2).v)  + ax(2.0,leg(j,3).v)  + leg(j,4).v));
//            printf("leg_vx = %f ",leg(j,0).v.x);
        }
        for(j=0; j<N+1; ++j){
            trunk(j,0).r = trunk(j,0).r + wx(6.0,(trunk(j,1).r + ax(2.0,trunk(j,2).r) + ax(2.0,trunk(j,3).r) + trunk(j,4).r));
            trunk(j,0).v = trunk(j,0).v + wx(6.0,(trunk(j,1).v + ax(2.0,trunk(j,2).v) + ax(2.0,trunk(j,3).v) + trunk(j,4).v));
        }

        time_step++;
        
        t=time_step*dt;                //現在の時刻t
        if(time_step%interval==0){
            
            printf("%f     ",(double)t);
            fprintf(fp,"%f    ",(double)t);
            for(j=0;j<N;j++){
                //printf("leg_x=%f  leg_z=%f  femur_x=%f  femur_z=%f  coxa_x=%f  coxa_z=%f  trunk_x=%f  trunk_z=%f  trunk_x=%f  trunk_z=%f  \n",leg(j,0).x,leg(j,0).z,femur(j,0).x,femur(j,0).z,coxa(j,0).x,coxa(j,0).z,trunk(j,0).x,trunk(j,0).z,trunk((j+1),0).x,trunk((j+1),0).z);
                //printf("et_tcx=%f  et_tcz=%f  en_tcx=%f  en_tcz=%f  et_ctx=%f  et_ctz=%f  en_ctx=%f  en_ctz=%f  \n",et_tc[i].x,et_tc[i].z,en_tc[i].x,en_tc[i].z,et_ct[i].x,et_ct[i].z,en_ct[i].x,en_ct[i].z);
                fprintf(fp,"phi[%d]= %f ",j, coil_tcl[j].phi_v);
                fprintf(fp,"x[%d]= %f " ,j, childa[j].x);
            }
            
            printf("\n");
            fprintf(fp,"\n");
            
            monitor.SetCentering(trunk(N/2,0).r.x , 0.0 );
            
        }
    }
    
    if(time_step >= MAX_STEP){ //MAX_STEPに達したらプログラムを終了
        fclose(fp);
        exit(0);
    }
    return 0;
}

void idle(void)
{
    glutSetWindow(winid);
    glutPostRedisplay();
}

void display(void)
{
    int i,j;
    
    glClear(GL_COLOR_BUFFER_BIT);
    glLoadIdentity();
    
    runge();        //runge-kuttaを回す
    
    
    /**linkの描画**/
    monitor.SetAllColor(0.0, 0.0, 0.0);
    for(j=0;j<N;++j){
        monitor.DrawLine(trunk(j,0).r.x ,trunk(j,0).r.z,coxa(j,0).r.x,coxa(j,0).r.z , 2.0);
        monitor.DrawLine(coxa(j,0).r.x ,coxa(j,0).r.z,trunk(j+1,0).r.x,trunk(j+1,0).r.z , 2.0);
        monitor.DrawLine(coxa(j,0).r.x ,coxa(j,0).r.z,leg(j,0).r.x,leg(j,0).r.z , 2.0);
    }
    
    /**地面の描画**/
    monitor.SetAllColor(0.7, 0.7, 0.7);
    monitor.DrawRectangle( -1000 , 0 , boko_start, -1000);
    monitor.DrawRectangle( boko_start + (boko + deko)*(N_dekoboko - 1 ) + boko , 0 , 1000 , -1000 );
    for(int i=0; i<N_dekoboko-1; ++i){
        monitor.DrawRectangle( boko_start + boko + (deko + boko)*i , 0 , boko_start +  (deko + boko)*(i + 1) , -1000 );
    }
//    monitor.DrawRectangle( -1000 , 0 , 1000 , -1000);

    monitor.SetAllColor(0.7,0.7,0.7);
    for(int i=0; i<1000 ; ++i){
        monitor.DrawLine(-100.0+5*i,10.0,-100.0+5*i,-10.0,0.1);
    }


    /**現在の座標の表示**/
    for(j=0;j<N;j++){
        if(state[j] == "swing"){

        //     if(Fl_N[j].z == 0.0){
        //         monitor.SetAllColor(0.0,0.0,1.0);
        //     }else{
        //         monitor.SetAllColor(0.0,0.0,0.5);
        //     }

        monitor.SetAllColor(0.0,0.0,1.0);

        }
        else if(state[j] == "stance"){

            // if(Fl_N[j].z == 0.0){
            //     monitor.SetAllColor(0.5,0.0,0.0);
            // }else{
            //     monitor.SetAllColor(1.0,0.0,0.0);
            //
        monitor.SetAllColor(1.0,0.0,0.0);

        }
        else{
            monitor.SetAllColor(0.0,1.0,0.0);
        }
        monitor.DrawCircle(coxa(j,0).r.x, coxa(j,0).r.z , 0.2); //円
        monitor.DrawCircle(leg(j,0).r.x, leg(j,0).r.z , 0.2); //円
    }
    
    for(j=0;j<(N+1);j++){
        monitor.SetAllColor(0.0,0.0,0.0);
        monitor.DrawCircle(trunk(j,0).r.x, trunk(j,0).r.z , 0.25); //円
    }
    
    /*パラメータの表示*/
    monitor.SetAllColor(0.0,0.0,0.0);
    
    sprintf(string,"time  = %f s",time_step*dt);
    monitor.String(-0.95,0.9,string);
    sprintf(string,"Vswing  = %f",Vswing);
    monitor.String(-0.95,0.7,string);
    sprintf(string,"Vstance = %f",Vstance);
    monitor.String(-0.95,0.6,string);
    sprintf(string,"Vlanding= %f",Vlanding);
    monitor.String(-0.95,0.5,string);
    sprintf(string,"x_AEP = %f",x_AEP);
    monitor.String(-0.95,0.4,string);
    // sprintf(string,"x_PEP = %f",x_PEP);
    // monitor.String(-0.95,0.3,string);
    // sprintf(string,"L    = %f",L);
    // monitor.String(-0.95,0.2,string);
    // sprintf(string,"beta1 = %f",beta1);
    // monitor.String(-0.95,0.1,string);


    sprintf(string,"x_wait= %f",x_wait);
    monitor.String(-0.60,0.9,string);
    sprintf(string,"x_get= %f",x_get);
    monitor.String(-0.60,0.8,string);
    sprintf(string,"x_lost= %f",x_lost);
    monitor.String(-0.60,0.7,string);
    sprintf(string,"N_contact= %f",N_contact);
    monitor.String(-0.60,0.6,string);
    sprintf(string,"N_get= %f",N_get);
    monitor.String(-0.60,0.5,string);  
    sprintf(string,"N_lost= %f",N_lost);
    monitor.String(-0.60,0.4,string);  
    


//    for(j=0;j<N;++j){
//        sprintf(string,"psi[%d] = %f",j,psi[j]);
//        monitor.String(-0.25+0.25*(j/6),0.9-0.1*(j%6),string);
//    }

   for(j=0;j<N;++j){
       sprintf(string,"phiv[%d] = %f",j,coil_tcl[j].phi_v);
       monitor.String(-0.25+0.25*(j/6),0.9-0.1*(j%6),string);
   }
    
//    for(j=0;j<N;++j){
//        sprintf(string,"c[%d].x = %f",j,childa[j].x);
//        monitor.String(-0.25+0.25*(j/6),0.9-0.1*(j%6),string);
//    }
    
    // for(j=0;j<N;++j){
    //     sprintf(string,"N[%d].x = %f",j,Fl_N[j].z);
    //     monitor.String(-0.25+0.3*(j/6),0.9-0.1*(j%6),string);
    // }
        

    // for(j=0;j<N;++j){
    //    sprintf(string,"tau[%d] = %f",j,coil_tcl[j].tau_limit(tau_0 , dotbartheta[j] ));
    //    monitor.String(-0.25+0.25*(j/6),0.9-0.1*(j%6),string);
    // }

    sprintf(string,"v = %f cm/s",trunk(0,0).v.x * 0.002 * 100);
    monitor.String(0.65,0.4,string);
    
    sprintf(string,"c_tct  = %f",c_tct);
    monitor.String(-0.95,-0.3,string);
    sprintf(string,"k_tct  = %f",k_tct);
    monitor.String(-0.95,-0.4,string);
    sprintf(string,"c_ctc  = %f",c_ctc);
    monitor.String(-0.95,-0.5,string);
    sprintf(string,"k_ctc  = %f",k_ctc);
    monitor.String(-0.95,-0.6,string);
    sprintf(string,"c_tcl  = %f",c_tcl);
    monitor.String(-0.95,-0.7,string);
    sprintf(string,"k_tcl  = %f",k_tcl);
    monitor.String(-0.95,-0.8,string);
    
    
    sprintf(string,"l_tc  = %f",leq_tc);
    monitor.String(-0.60,-0.3,string);
    sprintf(string,"c_tc  = %f",c_tc);
    monitor.String(-0.60,-0.4,string);
    sprintf(string,"k_tc  = %f",k_tc);
    monitor.String(-0.60,-0.5,string);
    sprintf(string,"l_cl  = %f",leq_cl);
    monitor.String(-0.60,-0.6,string);
    sprintf(string,"c_cl  = %f",c_cl);
    monitor.String(-0.60,-0.7,string);
    sprintf(string,"k_cl  = %f",k_cl);
    monitor.String(-0.60,-0.8,string);
    
    sprintf(string,"m_trunk  = %f",m_trunk);
    monitor.String(-0.25,-0.3,string);
    sprintf(string,"m_coxa  = %f",m_coxa);
    monitor.String(-0.25,-0.4,string);
    sprintf(string,"m_leg  = %f",m_leg);
    monitor.String(-0.25,-0.5,string);
    sprintf(string,"mu = %f",mu);
    monitor.String(-0.25,-0.6,string);
    sprintf(string,"c_tanh = %f",c_tanh);
    monitor.String(-0.25,-0.7,string);
    sprintf(string,"c_g  = %f",c_g);
    monitor.String(-0.25,-0.8,string);
    sprintf(string,"k_g  = %f",k_g);
    monitor.String(-0.25,-0.9,string);

    sprintf(string,"FTC_control  = %d",FTC_control);
    monitor.String(0.05,-0.3,string);
    sprintf(string,"CP_get  = %d",CP_get);
    monitor.String(0.05,-0.4,string);
    sprintf(string,"CP_lost  = %d",CP_lost);
    monitor.String(0.05,-0.5,string);
    sprintf(string,"muscle  = %d",muscle_properity);
    monitor.String(0.05,-0.6,string);

    glFlush();
    glutSwapBuffers();
    
    if(save_flag==1){    //saveflagが1なら画像を保存
        if(!(time_step%interval)) {monitor.SavePPMData();  }
    }
    
}


void keyboard(unsigned char key, int x , int y){
    double tmpcin;
    switch(key)
    {
        case 'Q'   :                                break;
        case 'q'   :                                break;
        case '\033':  /* '\033' = ESC */ exit(0);   break;
        case 'h'   : monitor.SetCenter( 1.0 , 0 );  break;
        case 'l'   : monitor.SetCenter( -1.0 , 0 ); break;
        case 'j'   : monitor.SetCenter( 0 , 1.0 );  break;
        case 'k'   : monitor.SetCenter( 0 , -1.0 ); break;            
        //振幅のキーボード制御
        case 'c'   : ;                              break;
        case 'g'   : ;                              break;
        case 'z'   : monitor.SetZoom( 1.1 );        break;
        case 'x'   : monitor.SetZoom( 1.0 / 1.1 );  break;
    }
    
}


void mouse(int button, int state, int x, int y)
{
    switch (button)
    {
        case GLUT_LEFT_BUTTON:
            if (state == GLUT_DOWN) { glutIdleFunc(0);     std::cout << "left: on" << std::endl;  }
            else                    { glutIdleFunc(idle);  std::cout << "left: off" << std::endl; }
            break;
            
        case GLUT_MIDDLE_BUTTON:
            if (state == GLUT_DOWN) { glutIdleFunc(0);    std::cout << "middle: on" << std::endl;  }
            else                    { glutIdleFunc(idle); std::cout << "middle: off" << std::endl; }
            break;
            
        case GLUT_RIGHT_BUTTON:
            if (state == GLUT_DOWN) { glutIdleFunc(0);    std::cout << "right: on" << std::endl;  }
            else                    { glutIdleFunc(idle); std::cout << "right: off" << std::endl; }
            break;
    }
}

void resize( int w , int h )
{
    glViewport(0, 0, w, h);
    
    //glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho( -w / 20.0 , w / 20.0 , -h / 20.0 , h / 20.0 , -1.0 , 1.0 );
    //gluPerspective( 30.0, (double)w / (double)h, 1.0 , 100.0 );
    //gluLookAt( 0.0 , 0.0 , 3.8 , 0.0 , 0.0 , 0.0 , 0.0 , 1.0 , 0.0 );
    //monitor.SetWindowSize( w , h );
    //glMatrixMode(GL_MODELVIEW);
}

void OpenGL_init(int *argcp , char **argv)
{
    init();        //初期条件を設定
    
    glutInit(argcp, argv);
    
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
    
    glutInitWindowSize(monitor.GetWindowSize(Monitor::X),monitor.GetWindowSize(Monitor::Y));
    glutInitWindowPosition( 10 , 100 );
    winid = glutCreateWindow("simulation");
    glutDisplayFunc(display);
    glutReshapeFunc(resize);
    glutKeyboardFunc(keyboard);
    glutMouseFunc(mouse);
    glClearColor(1.0, 1.0, 1.0, 1.0);
}

void monitor_init()
{
    monitor.SetWindowSize( 2000 , 400 );
    //   monitor.SetMode( 0 );
    monitor.SetMovieMode( 1 );
    monitor.SetMovieName( "./MovieDir/temp_" );
    //   monitor.SetGridMode( 0 );
    //   monitor.SetGridWidth( 2.0 );
    
    for( int i = 0 ; i < 8 ; i++ ) monitor.SetZoom( 0.9 );
    // for( int i = 0 ; i < 7; i++ ) monitor.SetCenter( 0 , 1.0 );
    for( int i = 0 ; i < N ; i++ ) monitor.SetCenter( 0.5 , 0.0 );
    
}


int main(int argc, char *argv[])
{
    
    monitor_init();
    std::cout << "monitor init OK" << std::endl;
    
    OpenGL_init(&argc, argv);
    
    std::cout << "OpenGL init OK" << std::endl;
    
    glutIdleFunc(idle);
    glutMainLoop();
    
    return 0;
}

